/** 
* Advent of Code 2021
* Day 16
* Author: zachy-ho (https://github.com/zachy-ho)
* */

import run from "aocrunner";

/* Types */
type Packet = Literal | Operator;

type Base = {
  version: number,
  typeId: number
}

type Literal = Base & {
  type: 'literal',
  literalValue: string
}

type Operator = Base & {
  type: 'operator'
  lengthTypeId: string
  children: Packet[]
}

type ParseResult = {
  packet: Packet,
  bitsParsed: number
}

/* Classes */
/* Ad-hoc objects */
/* Functions */
const parseInput = (rawInput: string) => { 
  return hex2bin(rawInput);
};

const parseHeader = (headerBin: string): { version: number, typeId: number } => {
  return {
    version: parseInt(bin2dec(headerBin.slice(0, 3))),
    typeId: parseInt(bin2dec(headerBin.slice(3))),
  }
}

// TODO: Your parsing is wrong somewhere
const gigaChadParse = (bin: string): ParseResult | null => {
  if (bin.length === 0) return null;
  const { version, typeId } = parseHeader(bin.slice(0, 6));
  let bitsParsed: number = 6;
  let packet: Packet;
  // console.log(bin.length);
  if (isLiteral(typeId)) {
    console.log('l')
    console.log(bin);
    let literalValue = '';
    let sectionBitsParsed = 0;
    while (true) {
      let section = nextLiteralSection(bin.slice(bitsParsed));
      // console.log(section);
      sectionBitsParsed += section.length;
      bitsParsed += section.length;
      literalValue.concat(section.slice(1));
      if (isFinalLiteralSection(section)) break;
    }
    // let remainder = sectionBitsParsed % 4;
    // if (remainder !== 0) {
      // bitsParsed += 4 - remainder;
    // }
    packet = {
      type: 'literal',
      version,
      typeId,
      literalValue
    }
  } else {
    const lengthTypeId = bin.slice(bitsParsed, bitsParsed + 1);
    bitsParsed++;
    const children: Packet[] = [];
    if (lengthTypeId === '0') {
      console.log('o0')
      console.log(bin);
      const subPacketLength = parseSubPacketLength(bin.slice(bitsParsed));
      bitsParsed += 15;
      let res: ParseResult | null;
      let bitsToParse = 0;
      while (bitsToParse < subPacketLength) {
        // console.log('how many')
        res = gigaChadParse(bin.slice(bitsParsed));
        if (res === null) continue;
        bitsParsed += res.bitsParsed;
        bitsToParse += res.bitsParsed;
        children.push(res.packet);
      } 
    } else {
      console.log('o1')
      console.log(bin);
      const numSubPackets = parseNumSubPackets(bin.slice(bitsParsed));
      bitsParsed += 11;
      let processed = 0;
      while (processed < numSubPackets) {
        console.log('this')
        const res = gigaChadParse(bin.slice(bitsParsed));
        if (res === null) continue;
        bitsParsed += res.bitsParsed;
        children.push(res.packet);
        processed++;
      }
    }
    packet = {
      type: 'operator',
      version,
      typeId,
      lengthTypeId,
      children
    }
  }

  return {
    packet,
    bitsParsed
  };
}

const parseNumSubPackets = (bin: string): number => {
  return parseInt(bin2dec(bin.slice(0, 11)));
}

const parseSubPacketLength = (bin: string): number => {
  return parseInt(bin2dec(bin.slice(0, 15)));
}

const isFinalLiteralSection = (section: string): boolean => {
  return section[0] === '0';
}

const nextLiteralSection = (bin: string): string => {
  return bin.slice(0, 5);
}

const isLiteral = (typeId: number): boolean => {
  return typeId === 4;
}

const hex2bin = (hex: string): string => {
  return parseInt(hex, 16).toString(2);
}

const bin2dec = (bin: string) : string => {
  return parseInt(bin, 2).toString(10);
}

const sumVersionNumbers = (packet: Packet) => {
  let versionNumber = packet.version;
  if (packet.type === 'operator') {
    packet.children.forEach((child) => versionNumber += sumVersionNumbers(child))
  } 
  return versionNumber
}

/* Part 1: Sum of all version numbers 
* If you get lost while working on this: this shit is probably just a lot of if statements and recursions
* */
const part1 = (rawInput: string) => {
  const bin = parseInput(rawInput);

  const res = gigaChadParse(bin);

  console.log('any')
  const sum = sumVersionNumbers(res!.packet);
  return sum;
};

/* Part 2: Description */
const part2 = (rawInput: string) => {
  const input = parseInput(rawInput);

  return;
};

/* Testing & running */
run({
  part1: {
    tests: [
      // {
        // input: `EE00D40C823060`,
        // expected: 16,
      // },
      // {
        // input: `8A004A801A8002F478`,
        // expected: 16,
      // },
      {
        input: `620080001611562C8802118E34`,
        expected: 12,
      },
      // {
        // input: `C0015000016115A2E0802F182340`,
        // expected: 23,
      // },
      // {
        // input: `A0016C880162017C3686B18A3D4780`,
        // expected: 31,
      // },
    ],
    solution: part1,
  },
  part2: {
    tests: [
      // {
      //   input: ``,
      //   expected: "",
      // },
    ],
    solution: part2,
  },
  trimTestInputs: true,
  onlyTests: true,
});
